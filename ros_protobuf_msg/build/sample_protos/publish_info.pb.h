// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: publish_info.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_publish_5finfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_publish_5finfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_publish_5finfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_publish_5finfo_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_publish_5finfo_2eproto;
namespace Excavator {
namespace data {
class Camera;
class CameraDefaultTypeInternal;
extern CameraDefaultTypeInternal _Camera_default_instance_;
class ImageData;
class ImageDataDefaultTypeInternal;
extern ImageDataDefaultTypeInternal _ImageData_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class PointCloud;
class PointCloudDefaultTypeInternal;
extern PointCloudDefaultTypeInternal _PointCloud_default_instance_;
class PublishInfo;
class PublishInfoDefaultTypeInternal;
extern PublishInfoDefaultTypeInternal _PublishInfo_default_instance_;
class SensorMetadata;
class SensorMetadataDefaultTypeInternal;
extern SensorMetadataDefaultTypeInternal _SensorMetadata_default_instance_;
}  // namespace data
}  // namespace Excavator
PROTOBUF_NAMESPACE_OPEN
template<> ::Excavator::data::Camera* Arena::CreateMaybeMessage<::Excavator::data::Camera>(Arena*);
template<> ::Excavator::data::ImageData* Arena::CreateMaybeMessage<::Excavator::data::ImageData>(Arena*);
template<> ::Excavator::data::Point* Arena::CreateMaybeMessage<::Excavator::data::Point>(Arena*);
template<> ::Excavator::data::PointCloud* Arena::CreateMaybeMessage<::Excavator::data::PointCloud>(Arena*);
template<> ::Excavator::data::PublishInfo* Arena::CreateMaybeMessage<::Excavator::data::PublishInfo>(Arena*);
template<> ::Excavator::data::SensorMetadata* Arena::CreateMaybeMessage<::Excavator::data::SensorMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Excavator {
namespace data {

enum ImageData_PixelFormat : int {
  ImageData_PixelFormat_MONO8 = 0,
  ImageData_PixelFormat_RGB8 = 1,
  ImageData_PixelFormat_BGR8 = 2,
  ImageData_PixelFormat_RGBA8 = 3,
  ImageData_PixelFormat_YUV420 = 4,
  ImageData_PixelFormat_ImageData_PixelFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImageData_PixelFormat_ImageData_PixelFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImageData_PixelFormat_IsValid(int value);
constexpr ImageData_PixelFormat ImageData_PixelFormat_PixelFormat_MIN = ImageData_PixelFormat_MONO8;
constexpr ImageData_PixelFormat ImageData_PixelFormat_PixelFormat_MAX = ImageData_PixelFormat_YUV420;
constexpr int ImageData_PixelFormat_PixelFormat_ARRAYSIZE = ImageData_PixelFormat_PixelFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageData_PixelFormat_descriptor();
template<typename T>
inline const std::string& ImageData_PixelFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageData_PixelFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageData_PixelFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageData_PixelFormat_descriptor(), enum_t_value);
}
inline bool ImageData_PixelFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageData_PixelFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageData_PixelFormat>(
    ImageData_PixelFormat_descriptor(), name, value);
}
// ===================================================================

class PublishInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Excavator.data.PublishInfo) */ {
 public:
  inline PublishInfo() : PublishInfo(nullptr) {}
  virtual ~PublishInfo();

  PublishInfo(const PublishInfo& from);
  PublishInfo(PublishInfo&& from) noexcept
    : PublishInfo() {
    *this = ::std::move(from);
  }

  inline PublishInfo& operator=(const PublishInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishInfo& operator=(PublishInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PublishInfo& default_instance();

  static inline const PublishInfo* internal_default_instance() {
    return reinterpret_cast<const PublishInfo*>(
               &_PublishInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PublishInfo& a, PublishInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PublishInfo* New() const final {
    return CreateMaybeMessage<PublishInfo>(nullptr);
  }

  PublishInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PublishInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PublishInfo& from);
  void MergeFrom(const PublishInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Excavator.data.PublishInfo";
  }
  protected:
  explicit PublishInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_publish_5finfo_2eproto);
    return ::descriptor_table_publish_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorTestFieldNumber = 5,
    kTopicNameFieldNumber = 1,
    kMessageTypeFieldNumber = 2,
    kQueueSizeFieldNumber = 3,
    kIsLatchedFieldNumber = 4,
  };
  // repeated double vector_test = 5;
  int vector_test_size() const;
  private:
  int _internal_vector_test_size() const;
  public:
  void clear_vector_test();
  private:
  double _internal_vector_test(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_vector_test() const;
  void _internal_add_vector_test(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_vector_test();
  public:
  double vector_test(int index) const;
  void set_vector_test(int index, double value);
  void add_vector_test(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      vector_test() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_vector_test();

  // string topic_name = 1;
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // string message_type = 2;
  void clear_message_type();
  const std::string& message_type() const;
  void set_message_type(const std::string& value);
  void set_message_type(std::string&& value);
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  std::string* mutable_message_type();
  std::string* release_message_type();
  void set_allocated_message_type(std::string* message_type);
  private:
  const std::string& _internal_message_type() const;
  void _internal_set_message_type(const std::string& value);
  std::string* _internal_mutable_message_type();
  public:

  // uint32 queue_size = 3;
  void clear_queue_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 queue_size() const;
  void set_queue_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_queue_size() const;
  void _internal_set_queue_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool is_latched = 4;
  void clear_is_latched();
  bool is_latched() const;
  void set_is_latched(bool value);
  private:
  bool _internal_is_latched() const;
  void _internal_set_is_latched(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Excavator.data.PublishInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > vector_test_;
  mutable std::atomic<int> _vector_test_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 queue_size_;
  bool is_latched_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_publish_5finfo_2eproto;
};
// -------------------------------------------------------------------

class SensorMetadata PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Excavator.data.SensorMetadata) */ {
 public:
  inline SensorMetadata() : SensorMetadata(nullptr) {}
  virtual ~SensorMetadata();

  SensorMetadata(const SensorMetadata& from);
  SensorMetadata(SensorMetadata&& from) noexcept
    : SensorMetadata() {
    *this = ::std::move(from);
  }

  inline SensorMetadata& operator=(const SensorMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMetadata& operator=(SensorMetadata&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorMetadata& default_instance();

  static inline const SensorMetadata* internal_default_instance() {
    return reinterpret_cast<const SensorMetadata*>(
               &_SensorMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SensorMetadata& a, SensorMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMetadata* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorMetadata* New() const final {
    return CreateMaybeMessage<SensorMetadata>(nullptr);
  }

  SensorMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorMetadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorMetadata& from);
  void MergeFrom(const SensorMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Excavator.data.SensorMetadata";
  }
  protected:
  explicit SensorMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_publish_5finfo_2eproto);
    return ::descriptor_table_publish_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameIdFieldNumber = 1,
    kSensorIdFieldNumber = 3,
    kTemperatureFieldNumber = 4,
    kStatusCodeFieldNumber = 5,
  };
  // string frame_id = 1;
  void clear_frame_id();
  const std::string& frame_id() const;
  void set_frame_id(const std::string& value);
  void set_frame_id(std::string&& value);
  void set_frame_id(const char* value);
  void set_frame_id(const char* value, size_t size);
  std::string* mutable_frame_id();
  std::string* release_frame_id();
  void set_allocated_frame_id(std::string* frame_id);
  private:
  const std::string& _internal_frame_id() const;
  void _internal_set_frame_id(const std::string& value);
  std::string* _internal_mutable_frame_id();
  public:

  // string sensor_id = 3;
  void clear_sensor_id();
  const std::string& sensor_id() const;
  void set_sensor_id(const std::string& value);
  void set_sensor_id(std::string&& value);
  void set_sensor_id(const char* value);
  void set_sensor_id(const char* value, size_t size);
  std::string* mutable_sensor_id();
  std::string* release_sensor_id();
  void set_allocated_sensor_id(std::string* sensor_id);
  private:
  const std::string& _internal_sensor_id() const;
  void _internal_set_sensor_id(const std::string& value);
  std::string* _internal_mutable_sensor_id();
  public:

  // float temperature = 4;
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // uint32 status_code = 5;
  void clear_status_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 status_code() const;
  void set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_status_code() const;
  void _internal_set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Excavator.data.SensorMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_id_;
  float temperature_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_publish_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Point PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Excavator.data.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  virtual ~Point();

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Point& default_instance();

  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(nullptr);
  }

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Excavator.data.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_publish_5finfo_2eproto);
    return ::descriptor_table_publish_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kIntensityFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float intensity = 4;
  void clear_intensity();
  float intensity() const;
  void set_intensity(float value);
  private:
  float _internal_intensity() const;
  void _internal_set_intensity(float value);
  public:

  // @@protoc_insertion_point(class_scope:Excavator.data.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  float intensity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_publish_5finfo_2eproto;
};
// -------------------------------------------------------------------

class PointCloud PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Excavator.data.PointCloud) */ {
 public:
  inline PointCloud() : PointCloud(nullptr) {}
  virtual ~PointCloud();

  PointCloud(const PointCloud& from);
  PointCloud(PointCloud&& from) noexcept
    : PointCloud() {
    *this = ::std::move(from);
  }

  inline PointCloud& operator=(const PointCloud& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointCloud& operator=(PointCloud&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PointCloud& default_instance();

  static inline const PointCloud* internal_default_instance() {
    return reinterpret_cast<const PointCloud*>(
               &_PointCloud_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PointCloud& a, PointCloud& b) {
    a.Swap(&b);
  }
  inline void Swap(PointCloud* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointCloud* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PointCloud* New() const final {
    return CreateMaybeMessage<PointCloud>(nullptr);
  }

  PointCloud* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PointCloud>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PointCloud& from);
  void MergeFrom(const PointCloud& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointCloud* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Excavator.data.PointCloud";
  }
  protected:
  explicit PointCloud(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_publish_5finfo_2eproto);
    return ::descriptor_table_publish_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .Excavator.data.Point points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::Excavator::data::Point* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Excavator::data::Point >*
      mutable_points();
  private:
  const ::Excavator::data::Point& _internal_points(int index) const;
  ::Excavator::data::Point* _internal_add_points();
  public:
  const ::Excavator::data::Point& points(int index) const;
  ::Excavator::data::Point* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Excavator::data::Point >&
      points() const;

  // @@protoc_insertion_point(class_scope:Excavator.data.PointCloud)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Excavator::data::Point > points_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_publish_5finfo_2eproto;
};
// -------------------------------------------------------------------

class ImageData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Excavator.data.ImageData) */ {
 public:
  inline ImageData() : ImageData(nullptr) {}
  virtual ~ImageData();

  ImageData(const ImageData& from);
  ImageData(ImageData&& from) noexcept
    : ImageData() {
    *this = ::std::move(from);
  }

  inline ImageData& operator=(const ImageData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageData& operator=(ImageData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageData& default_instance();

  static inline const ImageData* internal_default_instance() {
    return reinterpret_cast<const ImageData*>(
               &_ImageData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ImageData& a, ImageData& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageData* New() const final {
    return CreateMaybeMessage<ImageData>(nullptr);
  }

  ImageData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageData& from);
  void MergeFrom(const ImageData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Excavator.data.ImageData";
  }
  protected:
  explicit ImageData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_publish_5finfo_2eproto);
    return ::descriptor_table_publish_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ImageData_PixelFormat PixelFormat;
  static constexpr PixelFormat MONO8 =
    ImageData_PixelFormat_MONO8;
  static constexpr PixelFormat RGB8 =
    ImageData_PixelFormat_RGB8;
  static constexpr PixelFormat BGR8 =
    ImageData_PixelFormat_BGR8;
  static constexpr PixelFormat RGBA8 =
    ImageData_PixelFormat_RGBA8;
  static constexpr PixelFormat YUV420 =
    ImageData_PixelFormat_YUV420;
  static inline bool PixelFormat_IsValid(int value) {
    return ImageData_PixelFormat_IsValid(value);
  }
  static constexpr PixelFormat PixelFormat_MIN =
    ImageData_PixelFormat_PixelFormat_MIN;
  static constexpr PixelFormat PixelFormat_MAX =
    ImageData_PixelFormat_PixelFormat_MAX;
  static constexpr int PixelFormat_ARRAYSIZE =
    ImageData_PixelFormat_PixelFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PixelFormat_descriptor() {
    return ImageData_PixelFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& PixelFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PixelFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PixelFormat_Name.");
    return ImageData_PixelFormat_Name(enum_t_value);
  }
  static inline bool PixelFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PixelFormat* value) {
    return ImageData_PixelFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRawDataFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kEncodingFieldNumber = 4,
    kStrideFieldNumber = 5,
  };
  // bytes raw_data = 1;
  void clear_raw_data();
  const std::string& raw_data() const;
  void set_raw_data(const std::string& value);
  void set_raw_data(std::string&& value);
  void set_raw_data(const char* value);
  void set_raw_data(const void* value, size_t size);
  std::string* mutable_raw_data();
  std::string* release_raw_data();
  void set_allocated_raw_data(std::string* raw_data);
  private:
  const std::string& _internal_raw_data() const;
  void _internal_set_raw_data(const std::string& value);
  std::string* _internal_mutable_raw_data();
  public:

  // uint32 width = 2;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 3;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .Excavator.data.ImageData.PixelFormat encoding = 4;
  void clear_encoding();
  ::Excavator::data::ImageData_PixelFormat encoding() const;
  void set_encoding(::Excavator::data::ImageData_PixelFormat value);
  private:
  ::Excavator::data::ImageData_PixelFormat _internal_encoding() const;
  void _internal_set_encoding(::Excavator::data::ImageData_PixelFormat value);
  public:

  // uint32 stride = 5;
  void clear_stride();
  ::PROTOBUF_NAMESPACE_ID::uint32 stride() const;
  void set_stride(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stride() const;
  void _internal_set_stride(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Excavator.data.ImageData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  int encoding_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stride_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_publish_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Camera PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Excavator.data.Camera) */ {
 public:
  inline Camera() : Camera(nullptr) {}
  virtual ~Camera();

  Camera(const Camera& from);
  Camera(Camera&& from) noexcept
    : Camera() {
    *this = ::std::move(from);
  }

  inline Camera& operator=(const Camera& from) {
    CopyFrom(from);
    return *this;
  }
  inline Camera& operator=(Camera&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Camera& default_instance();

  enum ImagePayloadCase {
    kRawImage = 7,
    kJpegEncoded = 8,
    IMAGE_PAYLOAD_NOT_SET = 0,
  };

  static inline const Camera* internal_default_instance() {
    return reinterpret_cast<const Camera*>(
               &_Camera_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Camera& a, Camera& b) {
    a.Swap(&b);
  }
  inline void Swap(Camera* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Camera* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Camera* New() const final {
    return CreateMaybeMessage<Camera>(nullptr);
  }

  Camera* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Camera>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Camera& from);
  void MergeFrom(const Camera& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Camera* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Excavator.data.Camera";
  }
  protected:
  explicit Camera(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_publish_5finfo_2eproto);
    return ::descriptor_table_publish_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntrinsicFieldNumber = 9,
    kDistortionFieldNumber = 10,
    kMetadataFieldNumber = 1,
    kFrameRateFieldNumber = 2,
    kExposureTimeFieldNumber = 3,
    kGainFieldNumber = 4,
    kFocalLengthFieldNumber = 5,
    kFNumberFieldNumber = 6,
    kRawImageFieldNumber = 7,
    kJpegEncodedFieldNumber = 8,
  };
  // repeated float intrinsic = 9;
  int intrinsic_size() const;
  private:
  int _internal_intrinsic_size() const;
  public:
  void clear_intrinsic();
  private:
  float _internal_intrinsic(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_intrinsic() const;
  void _internal_add_intrinsic(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_intrinsic();
  public:
  float intrinsic(int index) const;
  void set_intrinsic(int index, float value);
  void add_intrinsic(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      intrinsic() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_intrinsic();

  // repeated float distortion = 10;
  int distortion_size() const;
  private:
  int _internal_distortion_size() const;
  public:
  void clear_distortion();
  private:
  float _internal_distortion(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_distortion() const;
  void _internal_add_distortion(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_distortion();
  public:
  float distortion(int index) const;
  void set_distortion(int index, float value);
  void add_distortion(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      distortion() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_distortion();

  // .Excavator.data.SensorMetadata metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::Excavator::data::SensorMetadata& metadata() const;
  ::Excavator::data::SensorMetadata* release_metadata();
  ::Excavator::data::SensorMetadata* mutable_metadata();
  void set_allocated_metadata(::Excavator::data::SensorMetadata* metadata);
  private:
  const ::Excavator::data::SensorMetadata& _internal_metadata() const;
  ::Excavator::data::SensorMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::Excavator::data::SensorMetadata* metadata);
  ::Excavator::data::SensorMetadata* unsafe_arena_release_metadata();

  // float frame_rate = 2;
  void clear_frame_rate();
  float frame_rate() const;
  void set_frame_rate(float value);
  private:
  float _internal_frame_rate() const;
  void _internal_set_frame_rate(float value);
  public:

  // float exposure_time = 3;
  void clear_exposure_time();
  float exposure_time() const;
  void set_exposure_time(float value);
  private:
  float _internal_exposure_time() const;
  void _internal_set_exposure_time(float value);
  public:

  // float gain = 4;
  void clear_gain();
  float gain() const;
  void set_gain(float value);
  private:
  float _internal_gain() const;
  void _internal_set_gain(float value);
  public:

  // float focal_length = 5;
  void clear_focal_length();
  float focal_length() const;
  void set_focal_length(float value);
  private:
  float _internal_focal_length() const;
  void _internal_set_focal_length(float value);
  public:

  // float f_number = 6;
  void clear_f_number();
  float f_number() const;
  void set_f_number(float value);
  private:
  float _internal_f_number() const;
  void _internal_set_f_number(float value);
  public:

  // .Excavator.data.ImageData raw_image = 7;
  bool has_raw_image() const;
  private:
  bool _internal_has_raw_image() const;
  public:
  void clear_raw_image();
  const ::Excavator::data::ImageData& raw_image() const;
  ::Excavator::data::ImageData* release_raw_image();
  ::Excavator::data::ImageData* mutable_raw_image();
  void set_allocated_raw_image(::Excavator::data::ImageData* raw_image);
  private:
  const ::Excavator::data::ImageData& _internal_raw_image() const;
  ::Excavator::data::ImageData* _internal_mutable_raw_image();
  public:
  void unsafe_arena_set_allocated_raw_image(
      ::Excavator::data::ImageData* raw_image);
  ::Excavator::data::ImageData* unsafe_arena_release_raw_image();

  // string jpeg_encoded = 8;
  private:
  bool _internal_has_jpeg_encoded() const;
  public:
  void clear_jpeg_encoded();
  const std::string& jpeg_encoded() const;
  void set_jpeg_encoded(const std::string& value);
  void set_jpeg_encoded(std::string&& value);
  void set_jpeg_encoded(const char* value);
  void set_jpeg_encoded(const char* value, size_t size);
  std::string* mutable_jpeg_encoded();
  std::string* release_jpeg_encoded();
  void set_allocated_jpeg_encoded(std::string* jpeg_encoded);
  private:
  const std::string& _internal_jpeg_encoded() const;
  void _internal_set_jpeg_encoded(const std::string& value);
  std::string* _internal_mutable_jpeg_encoded();
  public:

  void clear_image_payload();
  ImagePayloadCase image_payload_case() const;
  // @@protoc_insertion_point(class_scope:Excavator.data.Camera)
 private:
  class _Internal;
  void set_has_raw_image();
  void set_has_jpeg_encoded();

  inline bool has_image_payload() const;
  inline void clear_has_image_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > intrinsic_;
  mutable std::atomic<int> _intrinsic_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > distortion_;
  mutable std::atomic<int> _distortion_cached_byte_size_;
  ::Excavator::data::SensorMetadata* metadata_;
  float frame_rate_;
  float exposure_time_;
  float gain_;
  float focal_length_;
  float f_number_;
  union ImagePayloadUnion {
    ImagePayloadUnion() {}
    ::Excavator::data::ImageData* raw_image_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jpeg_encoded_;
  } image_payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_publish_5finfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PublishInfo

// string topic_name = 1;
inline void PublishInfo::clear_topic_name() {
  topic_name_.ClearToEmpty();
}
inline const std::string& PublishInfo::topic_name() const {
  // @@protoc_insertion_point(field_get:Excavator.data.PublishInfo.topic_name)
  return _internal_topic_name();
}
inline void PublishInfo::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:Excavator.data.PublishInfo.topic_name)
}
inline std::string* PublishInfo::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:Excavator.data.PublishInfo.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& PublishInfo::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void PublishInfo::_internal_set_topic_name(const std::string& value) {
  
  topic_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PublishInfo::set_topic_name(std::string&& value) {
  
  topic_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Excavator.data.PublishInfo.topic_name)
}
inline void PublishInfo::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  topic_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:Excavator.data.PublishInfo.topic_name)
}
inline void PublishInfo::set_topic_name(const char* value,
    size_t size) {
  
  topic_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Excavator.data.PublishInfo.topic_name)
}
inline std::string* PublishInfo::_internal_mutable_topic_name() {
  
  return topic_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PublishInfo::release_topic_name() {
  // @@protoc_insertion_point(field_release:Excavator.data.PublishInfo.topic_name)
  return topic_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PublishInfo::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    
  } else {
    
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Excavator.data.PublishInfo.topic_name)
}

// string message_type = 2;
inline void PublishInfo::clear_message_type() {
  message_type_.ClearToEmpty();
}
inline const std::string& PublishInfo::message_type() const {
  // @@protoc_insertion_point(field_get:Excavator.data.PublishInfo.message_type)
  return _internal_message_type();
}
inline void PublishInfo::set_message_type(const std::string& value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:Excavator.data.PublishInfo.message_type)
}
inline std::string* PublishInfo::mutable_message_type() {
  // @@protoc_insertion_point(field_mutable:Excavator.data.PublishInfo.message_type)
  return _internal_mutable_message_type();
}
inline const std::string& PublishInfo::_internal_message_type() const {
  return message_type_.Get();
}
inline void PublishInfo::_internal_set_message_type(const std::string& value) {
  
  message_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PublishInfo::set_message_type(std::string&& value) {
  
  message_type_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Excavator.data.PublishInfo.message_type)
}
inline void PublishInfo::set_message_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:Excavator.data.PublishInfo.message_type)
}
inline void PublishInfo::set_message_type(const char* value,
    size_t size) {
  
  message_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Excavator.data.PublishInfo.message_type)
}
inline std::string* PublishInfo::_internal_mutable_message_type() {
  
  return message_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PublishInfo::release_message_type() {
  // @@protoc_insertion_point(field_release:Excavator.data.PublishInfo.message_type)
  return message_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PublishInfo::set_allocated_message_type(std::string* message_type) {
  if (message_type != nullptr) {
    
  } else {
    
  }
  message_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Excavator.data.PublishInfo.message_type)
}

// uint32 queue_size = 3;
inline void PublishInfo::clear_queue_size() {
  queue_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PublishInfo::_internal_queue_size() const {
  return queue_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PublishInfo::queue_size() const {
  // @@protoc_insertion_point(field_get:Excavator.data.PublishInfo.queue_size)
  return _internal_queue_size();
}
inline void PublishInfo::_internal_set_queue_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  queue_size_ = value;
}
inline void PublishInfo::set_queue_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_queue_size(value);
  // @@protoc_insertion_point(field_set:Excavator.data.PublishInfo.queue_size)
}

// bool is_latched = 4;
inline void PublishInfo::clear_is_latched() {
  is_latched_ = false;
}
inline bool PublishInfo::_internal_is_latched() const {
  return is_latched_;
}
inline bool PublishInfo::is_latched() const {
  // @@protoc_insertion_point(field_get:Excavator.data.PublishInfo.is_latched)
  return _internal_is_latched();
}
inline void PublishInfo::_internal_set_is_latched(bool value) {
  
  is_latched_ = value;
}
inline void PublishInfo::set_is_latched(bool value) {
  _internal_set_is_latched(value);
  // @@protoc_insertion_point(field_set:Excavator.data.PublishInfo.is_latched)
}

// repeated double vector_test = 5;
inline int PublishInfo::_internal_vector_test_size() const {
  return vector_test_.size();
}
inline int PublishInfo::vector_test_size() const {
  return _internal_vector_test_size();
}
inline void PublishInfo::clear_vector_test() {
  vector_test_.Clear();
}
inline double PublishInfo::_internal_vector_test(int index) const {
  return vector_test_.Get(index);
}
inline double PublishInfo::vector_test(int index) const {
  // @@protoc_insertion_point(field_get:Excavator.data.PublishInfo.vector_test)
  return _internal_vector_test(index);
}
inline void PublishInfo::set_vector_test(int index, double value) {
  vector_test_.Set(index, value);
  // @@protoc_insertion_point(field_set:Excavator.data.PublishInfo.vector_test)
}
inline void PublishInfo::_internal_add_vector_test(double value) {
  vector_test_.Add(value);
}
inline void PublishInfo::add_vector_test(double value) {
  _internal_add_vector_test(value);
  // @@protoc_insertion_point(field_add:Excavator.data.PublishInfo.vector_test)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
PublishInfo::_internal_vector_test() const {
  return vector_test_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
PublishInfo::vector_test() const {
  // @@protoc_insertion_point(field_list:Excavator.data.PublishInfo.vector_test)
  return _internal_vector_test();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
PublishInfo::_internal_mutable_vector_test() {
  return &vector_test_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
PublishInfo::mutable_vector_test() {
  // @@protoc_insertion_point(field_mutable_list:Excavator.data.PublishInfo.vector_test)
  return _internal_mutable_vector_test();
}

// -------------------------------------------------------------------

// SensorMetadata

// string frame_id = 1;
inline void SensorMetadata::clear_frame_id() {
  frame_id_.ClearToEmpty();
}
inline const std::string& SensorMetadata::frame_id() const {
  // @@protoc_insertion_point(field_get:Excavator.data.SensorMetadata.frame_id)
  return _internal_frame_id();
}
inline void SensorMetadata::set_frame_id(const std::string& value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:Excavator.data.SensorMetadata.frame_id)
}
inline std::string* SensorMetadata::mutable_frame_id() {
  // @@protoc_insertion_point(field_mutable:Excavator.data.SensorMetadata.frame_id)
  return _internal_mutable_frame_id();
}
inline const std::string& SensorMetadata::_internal_frame_id() const {
  return frame_id_.Get();
}
inline void SensorMetadata::_internal_set_frame_id(const std::string& value) {
  
  frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SensorMetadata::set_frame_id(std::string&& value) {
  
  frame_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Excavator.data.SensorMetadata.frame_id)
}
inline void SensorMetadata::set_frame_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:Excavator.data.SensorMetadata.frame_id)
}
inline void SensorMetadata::set_frame_id(const char* value,
    size_t size) {
  
  frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Excavator.data.SensorMetadata.frame_id)
}
inline std::string* SensorMetadata::_internal_mutable_frame_id() {
  
  return frame_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SensorMetadata::release_frame_id() {
  // @@protoc_insertion_point(field_release:Excavator.data.SensorMetadata.frame_id)
  return frame_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SensorMetadata::set_allocated_frame_id(std::string* frame_id) {
  if (frame_id != nullptr) {
    
  } else {
    
  }
  frame_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), frame_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Excavator.data.SensorMetadata.frame_id)
}

// string sensor_id = 3;
inline void SensorMetadata::clear_sensor_id() {
  sensor_id_.ClearToEmpty();
}
inline const std::string& SensorMetadata::sensor_id() const {
  // @@protoc_insertion_point(field_get:Excavator.data.SensorMetadata.sensor_id)
  return _internal_sensor_id();
}
inline void SensorMetadata::set_sensor_id(const std::string& value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:Excavator.data.SensorMetadata.sensor_id)
}
inline std::string* SensorMetadata::mutable_sensor_id() {
  // @@protoc_insertion_point(field_mutable:Excavator.data.SensorMetadata.sensor_id)
  return _internal_mutable_sensor_id();
}
inline const std::string& SensorMetadata::_internal_sensor_id() const {
  return sensor_id_.Get();
}
inline void SensorMetadata::_internal_set_sensor_id(const std::string& value) {
  
  sensor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SensorMetadata::set_sensor_id(std::string&& value) {
  
  sensor_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Excavator.data.SensorMetadata.sensor_id)
}
inline void SensorMetadata::set_sensor_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sensor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:Excavator.data.SensorMetadata.sensor_id)
}
inline void SensorMetadata::set_sensor_id(const char* value,
    size_t size) {
  
  sensor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Excavator.data.SensorMetadata.sensor_id)
}
inline std::string* SensorMetadata::_internal_mutable_sensor_id() {
  
  return sensor_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SensorMetadata::release_sensor_id() {
  // @@protoc_insertion_point(field_release:Excavator.data.SensorMetadata.sensor_id)
  return sensor_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SensorMetadata::set_allocated_sensor_id(std::string* sensor_id) {
  if (sensor_id != nullptr) {
    
  } else {
    
  }
  sensor_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sensor_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Excavator.data.SensorMetadata.sensor_id)
}

// float temperature = 4;
inline void SensorMetadata::clear_temperature() {
  temperature_ = 0;
}
inline float SensorMetadata::_internal_temperature() const {
  return temperature_;
}
inline float SensorMetadata::temperature() const {
  // @@protoc_insertion_point(field_get:Excavator.data.SensorMetadata.temperature)
  return _internal_temperature();
}
inline void SensorMetadata::_internal_set_temperature(float value) {
  
  temperature_ = value;
}
inline void SensorMetadata::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:Excavator.data.SensorMetadata.temperature)
}

// uint32 status_code = 5;
inline void SensorMetadata::clear_status_code() {
  status_code_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorMetadata::_internal_status_code() const {
  return status_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorMetadata::status_code() const {
  // @@protoc_insertion_point(field_get:Excavator.data.SensorMetadata.status_code)
  return _internal_status_code();
}
inline void SensorMetadata::_internal_set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  status_code_ = value;
}
inline void SensorMetadata::set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:Excavator.data.SensorMetadata.status_code)
}

// -------------------------------------------------------------------

// Point

// float x = 1;
inline void Point::clear_x() {
  x_ = 0;
}
inline float Point::_internal_x() const {
  return x_;
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Point::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Excavator.data.Point.x)
}

// float y = 2;
inline void Point::clear_y() {
  y_ = 0;
}
inline float Point::_internal_y() const {
  return y_;
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Point::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Excavator.data.Point.y)
}

// float z = 3;
inline void Point::clear_z() {
  z_ = 0;
}
inline float Point::_internal_z() const {
  return z_;
}
inline float Point::z() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Point.z)
  return _internal_z();
}
inline void Point::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Point::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Excavator.data.Point.z)
}

// float intensity = 4;
inline void Point::clear_intensity() {
  intensity_ = 0;
}
inline float Point::_internal_intensity() const {
  return intensity_;
}
inline float Point::intensity() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Point.intensity)
  return _internal_intensity();
}
inline void Point::_internal_set_intensity(float value) {
  
  intensity_ = value;
}
inline void Point::set_intensity(float value) {
  _internal_set_intensity(value);
  // @@protoc_insertion_point(field_set:Excavator.data.Point.intensity)
}

// -------------------------------------------------------------------

// PointCloud

// repeated .Excavator.data.Point points = 1;
inline int PointCloud::_internal_points_size() const {
  return points_.size();
}
inline int PointCloud::points_size() const {
  return _internal_points_size();
}
inline void PointCloud::clear_points() {
  points_.Clear();
}
inline ::Excavator::data::Point* PointCloud::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:Excavator.data.PointCloud.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Excavator::data::Point >*
PointCloud::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:Excavator.data.PointCloud.points)
  return &points_;
}
inline const ::Excavator::data::Point& PointCloud::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::Excavator::data::Point& PointCloud::points(int index) const {
  // @@protoc_insertion_point(field_get:Excavator.data.PointCloud.points)
  return _internal_points(index);
}
inline ::Excavator::data::Point* PointCloud::_internal_add_points() {
  return points_.Add();
}
inline ::Excavator::data::Point* PointCloud::add_points() {
  // @@protoc_insertion_point(field_add:Excavator.data.PointCloud.points)
  return _internal_add_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Excavator::data::Point >&
PointCloud::points() const {
  // @@protoc_insertion_point(field_list:Excavator.data.PointCloud.points)
  return points_;
}

// -------------------------------------------------------------------

// ImageData

// bytes raw_data = 1;
inline void ImageData::clear_raw_data() {
  raw_data_.ClearToEmpty();
}
inline const std::string& ImageData::raw_data() const {
  // @@protoc_insertion_point(field_get:Excavator.data.ImageData.raw_data)
  return _internal_raw_data();
}
inline void ImageData::set_raw_data(const std::string& value) {
  _internal_set_raw_data(value);
  // @@protoc_insertion_point(field_set:Excavator.data.ImageData.raw_data)
}
inline std::string* ImageData::mutable_raw_data() {
  // @@protoc_insertion_point(field_mutable:Excavator.data.ImageData.raw_data)
  return _internal_mutable_raw_data();
}
inline const std::string& ImageData::_internal_raw_data() const {
  return raw_data_.Get();
}
inline void ImageData::_internal_set_raw_data(const std::string& value) {
  
  raw_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ImageData::set_raw_data(std::string&& value) {
  
  raw_data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Excavator.data.ImageData.raw_data)
}
inline void ImageData::set_raw_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  raw_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:Excavator.data.ImageData.raw_data)
}
inline void ImageData::set_raw_data(const void* value,
    size_t size) {
  
  raw_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Excavator.data.ImageData.raw_data)
}
inline std::string* ImageData::_internal_mutable_raw_data() {
  
  return raw_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ImageData::release_raw_data() {
  // @@protoc_insertion_point(field_release:Excavator.data.ImageData.raw_data)
  return raw_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageData::set_allocated_raw_data(std::string* raw_data) {
  if (raw_data != nullptr) {
    
  } else {
    
  }
  raw_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Excavator.data.ImageData.raw_data)
}

// uint32 width = 2;
inline void ImageData::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageData::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageData::width() const {
  // @@protoc_insertion_point(field_get:Excavator.data.ImageData.width)
  return _internal_width();
}
inline void ImageData::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void ImageData::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:Excavator.data.ImageData.width)
}

// uint32 height = 3;
inline void ImageData::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageData::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageData::height() const {
  // @@protoc_insertion_point(field_get:Excavator.data.ImageData.height)
  return _internal_height();
}
inline void ImageData::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void ImageData::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:Excavator.data.ImageData.height)
}

// .Excavator.data.ImageData.PixelFormat encoding = 4;
inline void ImageData::clear_encoding() {
  encoding_ = 0;
}
inline ::Excavator::data::ImageData_PixelFormat ImageData::_internal_encoding() const {
  return static_cast< ::Excavator::data::ImageData_PixelFormat >(encoding_);
}
inline ::Excavator::data::ImageData_PixelFormat ImageData::encoding() const {
  // @@protoc_insertion_point(field_get:Excavator.data.ImageData.encoding)
  return _internal_encoding();
}
inline void ImageData::_internal_set_encoding(::Excavator::data::ImageData_PixelFormat value) {
  
  encoding_ = value;
}
inline void ImageData::set_encoding(::Excavator::data::ImageData_PixelFormat value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:Excavator.data.ImageData.encoding)
}

// uint32 stride = 5;
inline void ImageData::clear_stride() {
  stride_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageData::_internal_stride() const {
  return stride_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageData::stride() const {
  // @@protoc_insertion_point(field_get:Excavator.data.ImageData.stride)
  return _internal_stride();
}
inline void ImageData::_internal_set_stride(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  stride_ = value;
}
inline void ImageData::set_stride(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stride(value);
  // @@protoc_insertion_point(field_set:Excavator.data.ImageData.stride)
}

// -------------------------------------------------------------------

// Camera

// .Excavator.data.SensorMetadata metadata = 1;
inline bool Camera::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool Camera::has_metadata() const {
  return _internal_has_metadata();
}
inline void Camera::clear_metadata() {
  if (GetArena() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::Excavator::data::SensorMetadata& Camera::_internal_metadata() const {
  const ::Excavator::data::SensorMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::Excavator::data::SensorMetadata&>(
      ::Excavator::data::_SensorMetadata_default_instance_);
}
inline const ::Excavator::data::SensorMetadata& Camera::metadata() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Camera.metadata)
  return _internal_metadata();
}
inline void Camera::unsafe_arena_set_allocated_metadata(
    ::Excavator::data::SensorMetadata* metadata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Excavator.data.Camera.metadata)
}
inline ::Excavator::data::SensorMetadata* Camera::release_metadata() {
  
  ::Excavator::data::SensorMetadata* temp = metadata_;
  metadata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Excavator::data::SensorMetadata* Camera::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:Excavator.data.Camera.metadata)
  
  ::Excavator::data::SensorMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::Excavator::data::SensorMetadata* Camera::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::Excavator::data::SensorMetadata>(GetArena());
    metadata_ = p;
  }
  return metadata_;
}
inline ::Excavator::data::SensorMetadata* Camera::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable:Excavator.data.Camera.metadata)
  return _internal_mutable_metadata();
}
inline void Camera::set_allocated_metadata(::Excavator::data::SensorMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:Excavator.data.Camera.metadata)
}

// float frame_rate = 2;
inline void Camera::clear_frame_rate() {
  frame_rate_ = 0;
}
inline float Camera::_internal_frame_rate() const {
  return frame_rate_;
}
inline float Camera::frame_rate() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Camera.frame_rate)
  return _internal_frame_rate();
}
inline void Camera::_internal_set_frame_rate(float value) {
  
  frame_rate_ = value;
}
inline void Camera::set_frame_rate(float value) {
  _internal_set_frame_rate(value);
  // @@protoc_insertion_point(field_set:Excavator.data.Camera.frame_rate)
}

// float exposure_time = 3;
inline void Camera::clear_exposure_time() {
  exposure_time_ = 0;
}
inline float Camera::_internal_exposure_time() const {
  return exposure_time_;
}
inline float Camera::exposure_time() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Camera.exposure_time)
  return _internal_exposure_time();
}
inline void Camera::_internal_set_exposure_time(float value) {
  
  exposure_time_ = value;
}
inline void Camera::set_exposure_time(float value) {
  _internal_set_exposure_time(value);
  // @@protoc_insertion_point(field_set:Excavator.data.Camera.exposure_time)
}

// float gain = 4;
inline void Camera::clear_gain() {
  gain_ = 0;
}
inline float Camera::_internal_gain() const {
  return gain_;
}
inline float Camera::gain() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Camera.gain)
  return _internal_gain();
}
inline void Camera::_internal_set_gain(float value) {
  
  gain_ = value;
}
inline void Camera::set_gain(float value) {
  _internal_set_gain(value);
  // @@protoc_insertion_point(field_set:Excavator.data.Camera.gain)
}

// float focal_length = 5;
inline void Camera::clear_focal_length() {
  focal_length_ = 0;
}
inline float Camera::_internal_focal_length() const {
  return focal_length_;
}
inline float Camera::focal_length() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Camera.focal_length)
  return _internal_focal_length();
}
inline void Camera::_internal_set_focal_length(float value) {
  
  focal_length_ = value;
}
inline void Camera::set_focal_length(float value) {
  _internal_set_focal_length(value);
  // @@protoc_insertion_point(field_set:Excavator.data.Camera.focal_length)
}

// float f_number = 6;
inline void Camera::clear_f_number() {
  f_number_ = 0;
}
inline float Camera::_internal_f_number() const {
  return f_number_;
}
inline float Camera::f_number() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Camera.f_number)
  return _internal_f_number();
}
inline void Camera::_internal_set_f_number(float value) {
  
  f_number_ = value;
}
inline void Camera::set_f_number(float value) {
  _internal_set_f_number(value);
  // @@protoc_insertion_point(field_set:Excavator.data.Camera.f_number)
}

// .Excavator.data.ImageData raw_image = 7;
inline bool Camera::_internal_has_raw_image() const {
  return image_payload_case() == kRawImage;
}
inline bool Camera::has_raw_image() const {
  return _internal_has_raw_image();
}
inline void Camera::set_has_raw_image() {
  _oneof_case_[0] = kRawImage;
}
inline void Camera::clear_raw_image() {
  if (_internal_has_raw_image()) {
    if (GetArena() == nullptr) {
      delete image_payload_.raw_image_;
    }
    clear_has_image_payload();
  }
}
inline ::Excavator::data::ImageData* Camera::release_raw_image() {
  // @@protoc_insertion_point(field_release:Excavator.data.Camera.raw_image)
  if (_internal_has_raw_image()) {
    clear_has_image_payload();
      ::Excavator::data::ImageData* temp = image_payload_.raw_image_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    image_payload_.raw_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Excavator::data::ImageData& Camera::_internal_raw_image() const {
  return _internal_has_raw_image()
      ? *image_payload_.raw_image_
      : reinterpret_cast< ::Excavator::data::ImageData&>(::Excavator::data::_ImageData_default_instance_);
}
inline const ::Excavator::data::ImageData& Camera::raw_image() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Camera.raw_image)
  return _internal_raw_image();
}
inline ::Excavator::data::ImageData* Camera::unsafe_arena_release_raw_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Excavator.data.Camera.raw_image)
  if (_internal_has_raw_image()) {
    clear_has_image_payload();
    ::Excavator::data::ImageData* temp = image_payload_.raw_image_;
    image_payload_.raw_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Camera::unsafe_arena_set_allocated_raw_image(::Excavator::data::ImageData* raw_image) {
  clear_image_payload();
  if (raw_image) {
    set_has_raw_image();
    image_payload_.raw_image_ = raw_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Excavator.data.Camera.raw_image)
}
inline ::Excavator::data::ImageData* Camera::_internal_mutable_raw_image() {
  if (!_internal_has_raw_image()) {
    clear_image_payload();
    set_has_raw_image();
    image_payload_.raw_image_ = CreateMaybeMessage< ::Excavator::data::ImageData >(GetArena());
  }
  return image_payload_.raw_image_;
}
inline ::Excavator::data::ImageData* Camera::mutable_raw_image() {
  // @@protoc_insertion_point(field_mutable:Excavator.data.Camera.raw_image)
  return _internal_mutable_raw_image();
}

// string jpeg_encoded = 8;
inline bool Camera::_internal_has_jpeg_encoded() const {
  return image_payload_case() == kJpegEncoded;
}
inline void Camera::set_has_jpeg_encoded() {
  _oneof_case_[0] = kJpegEncoded;
}
inline void Camera::clear_jpeg_encoded() {
  if (_internal_has_jpeg_encoded()) {
    image_payload_.jpeg_encoded_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_image_payload();
  }
}
inline const std::string& Camera::jpeg_encoded() const {
  // @@protoc_insertion_point(field_get:Excavator.data.Camera.jpeg_encoded)
  return _internal_jpeg_encoded();
}
inline void Camera::set_jpeg_encoded(const std::string& value) {
  _internal_set_jpeg_encoded(value);
  // @@protoc_insertion_point(field_set:Excavator.data.Camera.jpeg_encoded)
}
inline std::string* Camera::mutable_jpeg_encoded() {
  // @@protoc_insertion_point(field_mutable:Excavator.data.Camera.jpeg_encoded)
  return _internal_mutable_jpeg_encoded();
}
inline const std::string& Camera::_internal_jpeg_encoded() const {
  if (_internal_has_jpeg_encoded()) {
    return image_payload_.jpeg_encoded_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Camera::_internal_set_jpeg_encoded(const std::string& value) {
  if (!_internal_has_jpeg_encoded()) {
    clear_image_payload();
    set_has_jpeg_encoded();
    image_payload_.jpeg_encoded_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  image_payload_.jpeg_encoded_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Camera::set_jpeg_encoded(std::string&& value) {
  // @@protoc_insertion_point(field_set:Excavator.data.Camera.jpeg_encoded)
  if (!_internal_has_jpeg_encoded()) {
    clear_image_payload();
    set_has_jpeg_encoded();
    image_payload_.jpeg_encoded_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  image_payload_.jpeg_encoded_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Excavator.data.Camera.jpeg_encoded)
}
inline void Camera::set_jpeg_encoded(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_jpeg_encoded()) {
    clear_image_payload();
    set_has_jpeg_encoded();
    image_payload_.jpeg_encoded_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  image_payload_.jpeg_encoded_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:Excavator.data.Camera.jpeg_encoded)
}
inline void Camera::set_jpeg_encoded(const char* value,
                             size_t size) {
  if (!_internal_has_jpeg_encoded()) {
    clear_image_payload();
    set_has_jpeg_encoded();
    image_payload_.jpeg_encoded_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  image_payload_.jpeg_encoded_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:Excavator.data.Camera.jpeg_encoded)
}
inline std::string* Camera::_internal_mutable_jpeg_encoded() {
  if (!_internal_has_jpeg_encoded()) {
    clear_image_payload();
    set_has_jpeg_encoded();
    image_payload_.jpeg_encoded_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return image_payload_.jpeg_encoded_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Camera::release_jpeg_encoded() {
  // @@protoc_insertion_point(field_release:Excavator.data.Camera.jpeg_encoded)
  if (_internal_has_jpeg_encoded()) {
    clear_has_image_payload();
    return image_payload_.jpeg_encoded_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Camera::set_allocated_jpeg_encoded(std::string* jpeg_encoded) {
  if (has_image_payload()) {
    clear_image_payload();
  }
  if (jpeg_encoded != nullptr) {
    set_has_jpeg_encoded();
    image_payload_.jpeg_encoded_.UnsafeSetDefault(jpeg_encoded);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(jpeg_encoded);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:Excavator.data.Camera.jpeg_encoded)
}

// repeated float intrinsic = 9;
inline int Camera::_internal_intrinsic_size() const {
  return intrinsic_.size();
}
inline int Camera::intrinsic_size() const {
  return _internal_intrinsic_size();
}
inline void Camera::clear_intrinsic() {
  intrinsic_.Clear();
}
inline float Camera::_internal_intrinsic(int index) const {
  return intrinsic_.Get(index);
}
inline float Camera::intrinsic(int index) const {
  // @@protoc_insertion_point(field_get:Excavator.data.Camera.intrinsic)
  return _internal_intrinsic(index);
}
inline void Camera::set_intrinsic(int index, float value) {
  intrinsic_.Set(index, value);
  // @@protoc_insertion_point(field_set:Excavator.data.Camera.intrinsic)
}
inline void Camera::_internal_add_intrinsic(float value) {
  intrinsic_.Add(value);
}
inline void Camera::add_intrinsic(float value) {
  _internal_add_intrinsic(value);
  // @@protoc_insertion_point(field_add:Excavator.data.Camera.intrinsic)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Camera::_internal_intrinsic() const {
  return intrinsic_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Camera::intrinsic() const {
  // @@protoc_insertion_point(field_list:Excavator.data.Camera.intrinsic)
  return _internal_intrinsic();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Camera::_internal_mutable_intrinsic() {
  return &intrinsic_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Camera::mutable_intrinsic() {
  // @@protoc_insertion_point(field_mutable_list:Excavator.data.Camera.intrinsic)
  return _internal_mutable_intrinsic();
}

// repeated float distortion = 10;
inline int Camera::_internal_distortion_size() const {
  return distortion_.size();
}
inline int Camera::distortion_size() const {
  return _internal_distortion_size();
}
inline void Camera::clear_distortion() {
  distortion_.Clear();
}
inline float Camera::_internal_distortion(int index) const {
  return distortion_.Get(index);
}
inline float Camera::distortion(int index) const {
  // @@protoc_insertion_point(field_get:Excavator.data.Camera.distortion)
  return _internal_distortion(index);
}
inline void Camera::set_distortion(int index, float value) {
  distortion_.Set(index, value);
  // @@protoc_insertion_point(field_set:Excavator.data.Camera.distortion)
}
inline void Camera::_internal_add_distortion(float value) {
  distortion_.Add(value);
}
inline void Camera::add_distortion(float value) {
  _internal_add_distortion(value);
  // @@protoc_insertion_point(field_add:Excavator.data.Camera.distortion)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Camera::_internal_distortion() const {
  return distortion_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Camera::distortion() const {
  // @@protoc_insertion_point(field_list:Excavator.data.Camera.distortion)
  return _internal_distortion();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Camera::_internal_mutable_distortion() {
  return &distortion_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Camera::mutable_distortion() {
  // @@protoc_insertion_point(field_mutable_list:Excavator.data.Camera.distortion)
  return _internal_mutable_distortion();
}

inline bool Camera::has_image_payload() const {
  return image_payload_case() != IMAGE_PAYLOAD_NOT_SET;
}
inline void Camera::clear_has_image_payload() {
  _oneof_case_[0] = IMAGE_PAYLOAD_NOT_SET;
}
inline Camera::ImagePayloadCase Camera::image_payload_case() const {
  return Camera::ImagePayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace data
}  // namespace Excavator

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Excavator::data::ImageData_PixelFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Excavator::data::ImageData_PixelFormat>() {
  return ::Excavator::data::ImageData_PixelFormat_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_publish_5finfo_2eproto
